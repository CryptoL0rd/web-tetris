<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TETRIS - Clean Version</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        :root {
            --primary: #00ff88;
            --secondary: #ffaa00;
            --danger: #ff4444;
            --bg-dark: linear-gradient(135deg, #0f0f23, #1a1a40);
            --bg-light: linear-gradient(135deg, #f0f8ff, #e6f3ff);
            --text-dark: #ffffff;
            --text-light: #333333;
            --glass-bg: rgba(255, 255, 255, 0.05);
            --glass-border: rgba(255, 255, 255, 0.1);
        }

        [data-theme="light"] {
            --primary: #2e7d32;
            --secondary: #f57c00;
            --danger: #d32f2f;
            --background: var(--bg-light);
            --text: var(--text-light);
            --glass-bg: rgba(0, 0, 0, 0.05);
            --glass-border: rgba(0, 0, 0, 0.1);
        }

        [data-theme="dark"] {
            --primary: #00ff88;
            --secondary: #ffaa00;
            --danger: #ff4444;
            --background: var(--bg-dark);
            --text: var(--text-dark);
            --glass-bg: rgba(255, 255, 255, 0.05);
            --glass-border: rgba(255, 255, 255, 0.1);
        }

        body {
            font-family: 'Courier New', monospace;
            background: var(--background);
            color: var(--text);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            transition: all 0.3s ease;
        }

        .game-container {
            display: grid;
            grid-template-columns: 1fr 200px;
            gap: 20px;
            max-width: 800px;
            width: 100%;
            background: var(--glass-bg);
            border-radius: 15px;
            padding: 25px;
            backdrop-filter: blur(10px);
            border: 2px solid var(--glass-border);
        }

        @media (max-width: 768px) {
            body { padding: 10px; }
            .game-container {
                grid-template-columns: 1fr;
                gap: 15px;
                padding: 15px;
                max-width: 100%;
            }
        }

        .game-canvas {
            background: rgba(0, 0, 0, 0.8);
            border: 3px solid var(--primary);
            border-radius: 10px;
            max-width: 100%;
            height: auto;
            aspect-ratio: 0.6;
        }

        .game-panel {
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid var(--glass-border);
            border-radius: 10px;
            padding: 20px;
        }

        .status-indicator {
            display: flex;
            align-items: center;
            margin-bottom: 20px;
        }

        .status-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 10px;
        }

        .status-dot.playing { background: var(--primary); }
        .status-dot.paused { background: var(--secondary); }
        .status-dot.game-over { background: var(--danger); }

        .score-display {
            font-size: 1.2rem;
            font-weight: bold;
            margin-bottom: 20px;
        }

        .game-controls {
            margin-bottom: 20px;
        }

        .control-btn {
            background: var(--primary);
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            color: #000;
            cursor: pointer;
            margin-right: 10px;
            transition: all 0.2s ease;
        }

        .control-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        .control-btn.secondary {
            background: var(--secondary);
        }

        .mobile-controls {
            display: none;
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            background: var(--glass-bg);
            border-radius: 20px;
            padding: 15px;
            backdrop-filter: blur(10px);
            border: 2px solid var(--glass-border);
        }

        @media (max-width: 768px) {
            .mobile-controls.show {
                display: flex;
            }
        }

        .control-group {
            display: flex;
            gap: 10px;
            margin: 0 10px;
        }

        .mobile-btn {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            border: 2px solid var(--primary);
            background: rgba(0, 255, 136, 0.1);
            color: var(--primary);
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            user-select: none;
        }

        .mobile-btn:active {
            background: rgba(0, 255, 136, 0.3);
            transform: scale(0.95);
        }

        .mobile-btn.large {
            width: 70px;
            height: 70px;
            font-size: 20px;
        }

        .mobile-btn.secondary {
            border-color: var(--secondary);
            color: var(--secondary);
        }

        .mobile-btn.danger {
            border-color: var(--danger);
            color: var(--danger);
        }

        .theme-toggle {
            position: absolute;
            top: 10px;
            right: 10px;
            background: var(--glass-bg);
            border: 2px solid var(--glass-border);
            color: var(--primary);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            cursor: pointer;
            font-size: 18px;
            transition: all 0.3s ease;
        }

        .system-status {
            font-size: 0.8rem;
            color: #666;
            margin-top: 20px;
            padding-top: 10px;
            border-top: 1px solid var(--glass-border);
        }

        .status-item {
            margin-bottom: 5px;
        }

        .status-ok { color: var(--primary); }
        .status-error { color: var(--danger); }
        .status-warning { color: var(--secondary); }
    </style>
</head>
<body>
    <div class="game-container">
        <h1 style="grid-column: 1 / -1; text-align: center; color: var(--primary); margin-bottom: 10px;">
            TETRIS
        </h1>

        <section>
            <canvas id="gameCanvas" class="game-canvas" width="300" height="600">
                Your browser does not support HTML5 Canvas.
            </canvas>
        </section>

        <aside class="game-panel">
            <div class="status-indicator">
                <div id="statusDot" class="status-dot paused"></div>
                <span id="statusText">Paused</span>
            </div>

            <div class="score-display">
                Score: <span id="scoreDisplay">0</span>
            </div>

            <div class="game-controls">
                <button class="control-btn" onclick="startGame()">START</button>
                <button class="control-btn secondary" onclick="togglePause()">PAUSE</button>
            </div>

            <div class="mobile-controls" id="mobileControls">
                <div class="control-group">
                    <div class="mobile-btn" onclick="rotatePiece()" title="–ü–æ–≤–æ—Ä–æ—Ç">‚Üª</div>
                </div>
                <div class="control-group">
                    <div class="mobile-btn" onclick="movePieceLeft()" title="–í–ª–µ–≤–æ">‚Üê</div>
                    <div class="mobile-btn" onclick="movePieceDown()" title="–í–Ω–∏–∑">‚Üì</div>
                    <div class="mobile-btn" onclick="movePieceRight()" title="–í–ø—Ä–∞–≤–æ">‚Üí</div>
                </div>
                <div class="control-group">
                    <div class="mobile-btn large" onclick="hardDropPiece()" title="Hard Drop">‚¨á</div>
                </div>
                <div class="control-group">
                    <div class="mobile-btn secondary" onclick="togglePause()" title="–ü–∞—É–∑–∞">‚è∏</div>
                </div>
                <div class="control-group">
                    <div class="mobile-btn danger" onclick="startGame()" title="–†–µ—Å—Ç–∞—Ä—Ç">‚Ü∫</div>
                </div>
            </div>

            <div class="system-status">
                <div class="status-item">Logger: <span class="status-ok">Active</span></div>
                <div class="status-item">Canvas: <span class="status-warning">Ready</span></div>
                <div class="status-item">Storage: <span class="status-warning">Ready</span></div>
            </div>
        </aside>
    </div>

    <button class="theme-toggle" onclick="toggleTheme()" id="themeToggle" title="Toggle theme">üåô</button>

    <script>
        // Theme System
        function initializeTheme() {
            const savedTheme = localStorage.getItem('tetris-theme');
            const systemPrefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;

            let theme = savedTheme || (systemPrefersDark ? 'dark' : 'light');
            applyTheme(theme);
            updateThemeIcon(theme);
        }

        function applyTheme(theme) {
            document.body.setAttribute('data-theme', theme);
            localStorage.setItem('tetris-theme', theme);
            updateThemeIcon(theme);
        }

        function toggleTheme() {
            const currentTheme = document.body.getAttribute('data-theme');
            const newTheme = currentTheme === 'light' ? 'dark' : 'light';
            applyTheme(newTheme);
        }

        function updateThemeIcon(theme) {
            const themeToggle = document.getElementById('themeToggle');
            if (themeToggle) {
                themeToggle.textContent = theme === 'light' ? '‚òÄÔ∏è' : 'üåô';
            }
        }

        // Logger System
        class Logger {
            constructor() {
                this.levels = { DEBUG: 0, INFO: 1, WARN: 2, ERROR: 3 };
                this.currentLevel = this.levels.INFO;
                this.errorCounts = { canvas: 0, storage: 0, input: 0, gameLogic: 0 };
            }

            log(level, message, context = 'SYSTEM') {
                const levelNum = this.levels[level] || this.levels.INFO;
                if (levelNum < this.currentLevel) return;

                const timestamp = new Date().toISOString();
                console.log(`[${timestamp}] [${level}] [${context}] ${message}`);
            }

            logGameEvent(event, data = null) {
                this.log('INFO', `Game: ${event}`, 'GAME', data);
            }
        }

        // Error Handler
        class ErrorHandler {
            constructor(logger) {
                this.logger = logger;
                this.errorQueue = [];
            }

            async handleError(error, context = 'UNKNOWN') {
                this.logger.log('ERROR', `Error in ${context}: ${error.message}`, context);
                this.errorQueue.push({
                    error: error.message,
                    context,
                    timestamp: Date.now()
                });
                return false;
            }

            updateSystemStatus(component, status) {
                const statusEl = document.querySelector(`.status-item:has-text("${component}") span`);
                if (statusEl) {
                    statusEl.textContent = status;
                    statusEl.className = `status-${status.includes('Error') ? 'error' : status.includes('Warning') ? 'warning' : 'ok'}`;
                }
            }
        }

        // Tetris Game Engine
        class TetrisGame {
            constructor(canvas) {
                this.logger = new Logger();
                this.errorHandler = new ErrorHandler(this.logger);

                this.ROWS = 20;
                this.COLS = 10;
                this.CELL_SIZE = this.calculateCellSize();

                this.initializeCanvas(canvas);
                this.initializeGameState();
                this.setupEventListeners();
                this.detectMobileDevice();

                this.logger.log('INFO', 'Tetris Game initialized successfully');
                this.updateSystemStatus();
            }

            calculateCellSize() {
                const screenWidth = window.innerWidth;
                return screenWidth <= 768 ? 25 : screenWidth <= 1024 ? 30 : 35;
            }

            initializeCanvas(canvas) {
                try {
                    if (!canvas) throw new Error('Canvas element not found');
                    this.ctx = canvas.getContext('2d');
                    if (!this.ctx) throw new Error('Failed to get 2D context');
                    this.updateSystemStatus('canvas', 'OK');
                } catch (error) {
                    this.errorHandler.handleError(error, 'CANVAS_INIT');
                    this.updateSystemStatus('canvas', 'Error');
                }
            }

            initializeGameState() {
                this.grid = Array(this.ROWS).fill().map(() => Array(this.COLS).fill(0));
                this.currentPiece = null;
                this.nextPiece = null;
                this.score = 0;
                this.lines = 0;
                this.level = 1;
                this.isPaused = true;
                this.isGameOver = false;

                this.generateNewPiece();
                this.updateUI();
            }

            generateNewPiece() {
                const pieces = [
                    { type: 'I', shape: [[1,1,1,1]], color: '#00f5ff' },
                    { type: 'O', shape: [[1,1],[1,1]], color: '#ffff00' },
                    { type: 'T', shape: [[0,1,0],[1,1,1]], color: '#800080' },
                    { type: 'S', shape: [[0,1,1],[1,1,0]], color: '#00ff00' },
                    { type: 'Z', shape: [[1,1,0],[0,1,1]], color: '#ff0000' },
                    { type: 'J', shape: [[1,0,0],[1,1,1]], color: '#0000ff' },
                    { type: 'L', shape: [[0,0,1],[1,1,1]], color: '#ff8c00' }
                ];

                this.currentPiece = {
                    ...pieces[Math.floor(Math.random() * pieces.length)],
                    row: 0,
                    col: Math.floor(this.COLS / 2) - 1
                };
            }

            setupEventListeners() {
                document.addEventListener('keydown', (event) => {
                    this.handleKeyPress(event);
                });

                window.addEventListener('resize', () => {
                    this.handleResize();
                });
            }

            detectMobileDevice() {
                const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||
                                window.innerWidth <= 768;

                if (isMobile) {
                    this.showMobileControls();
                }
            }

            showMobileControls() {
                const mobileControls = document.getElementById('mobileControls');
                if (mobileControls) {
                    mobileControls.classList.add('show');
                }
            }

            handleResize() {
                this.CELL_SIZE = this.calculateCellSize();
                this.updateCanvasSize();
            }

            updateCanvasSize() {
                if (!this.ctx) return;

                const container = this.ctx.canvas.parentElement;
                const containerWidth = container.clientWidth;
                const maxWidth = Math.min(containerWidth - 40, 400);

                const canvasWidth = this.COLS * this.CELL_SIZE;
                const canvasHeight = this.ROWS * this.CELL_SIZE;

                const aspectRatio = canvasWidth / canvasHeight;
                const newWidth = maxWidth;
                const newHeight = newWidth / aspectRatio;

                this.ctx.canvas.width = newWidth;
                this.ctx.canvas.height = newHeight;

                const scaleX = newWidth / (this.COLS * this.CELL_SIZE);
                const scaleY = newHeight / (this.ROWS * this.CELL_SIZE);

                this.ctx.scale(scaleX, scaleY);
            }

            handleKeyPress(event) {
                if (this.isGameOver) return;

                let handled = false;

                switch (event.code) {
                    case 'ArrowLeft':
                        handled = this.movePieceLeft();
                        break;
                    case 'ArrowRight':
                        handled = this.movePieceRight();
                        break;
                    case 'ArrowDown':
                        handled = this.movePieceDown();
                        break;
                    case 'ArrowUp':
                    case 'KeyZ':
                        handled = this.rotatePiece();
                        break;
                    case 'Space':
                        event.preventDefault();
                        handled = this.hardDropPiece() > 0;
                        break;
                    case 'KeyP':
                        this.togglePause();
                        handled = true;
                        break;
                    case 'KeyR':
                        this.startGame();
                        handled = true;
                        break;
                }

                if (handled) {
                    this.logger.logGameEvent('KEY_PRESS', { key: event.code });
                }
            }

            startGame() {
                this.initializeGameState();
                this.logger.logGameEvent('GAME_STARTED');
            }

            togglePause() {
                if (this.isGameOver) return;
                this.isPaused = !this.isPaused;
                this.updateUI();
                this.logger.logGameEvent(this.isPaused ? 'GAME_PAUSED' : 'GAME_RESUMED');
            }

            movePieceLeft() {
                if (!this.currentPiece || this.isPaused || this.isGameOver) return false;
                if (this.isValidPosition(this.currentPiece.row, this.currentPiece.col - 1)) {
                    this.currentPiece.col--;
                    return true;
                }
                return false;
            }

            movePieceRight() {
                if (!this.currentPiece || this.isPaused || this.isGameOver) return false;
                if (this.isValidPosition(this.currentPiece.row, this.currentPiece.col + 1)) {
                    this.currentPiece.col++;
                    return true;
                }
                return false;
            }

            movePieceDown() {
                if (!this.currentPiece || this.isPaused || this.isGameOver) return false;
                if (this.isValidPosition(this.currentPiece.row + 1, this.currentPiece.col)) {
                    this.currentPiece.row++;
                    return true;
                }
                return false;
            }

            rotatePiece() {
                if (!this.currentPiece || this.isPaused || this.isGameOver) return false;
                const rotatedShape = this.rotateMatrix(this.currentPiece.shape);
                if (this.isValidPositionWithShape(rotatedShape, this.currentPiece.row, this.currentPiece.col)) {
                    this.currentPiece.shape = rotatedShape;
                    return true;
                }
                return false;
            }

            hardDropPiece() {
                if (!this.currentPiece || this.isPaused || this.isGameOver) return 0;
                let dropDistance = 0;
                while (this.movePieceDown()) {
                    dropDistance++;
                }

                if (dropDistance > 0) {
                    this.score += dropDistance * 2;
                }

                return dropDistance;
            }

            isValidPosition(row, col) {
                const shape = this.currentPiece.shape;
                for (let r = 0; r < shape.length; r++) {
                    for (let c = 0; c < shape[r].length; c++) {
                        if (shape[r][c]) {
                            const newRow = row + r;
                            const newCol = col + c;
                            if (newRow < 0 || newRow >= this.ROWS || newCol < 0 || newCol >= this.COLS || this.grid[newRow][newCol]) {
                                return false;
                            }
                        }
                    }
                }
                return true;
            }

            isValidPositionWithShape(shape, row, col) {
                for (let r = 0; r < shape.length; r++) {
                    for (let c = 0; c < shape[r].length; c++) {
                        if (shape[r][c]) {
                            const newRow = row + r;
                            const newCol = col + c;
                            if (newRow < 0 || newRow >= this.ROWS || newCol < 0 || newCol >= this.COLS || this.grid[newRow][newCol]) {
                                return false;
                            }
                        }
                    }
                }
                return true;
            }

            rotateMatrix(matrix) {
                const rows = matrix.length;
                const cols = matrix[0].length;
                const rotated = Array(cols).fill().map(() => Array(rows).fill(0));

                for (let i = 0; i < rows; i++) {
                    for (let j = 0; j < cols; j++) {
                        rotated[j][rows - 1 - i] = matrix[i][j];
                    }
                }

                return rotated;
            }

            gameLoop(currentTime = 0) {
                if (this.isGameOver || this.isPaused) {
                    this.draw();
                    requestAnimationFrame((time) => this.gameLoop(time));
                    return;
                }

                this.updateGameLogic();
                this.draw();

                requestAnimationFrame((time) => this.gameLoop(time));
            }

            updateGameLogic() {
                const dropInterval = Math.max(100, 1000 - (this.level - 1) * 100);

                if (Date.now() - (this.lastDropTime || 0) > dropInterval) {
                    if (!this.movePieceDown()) {
                        this.placePiece();
                    }
                    this.lastDropTime = Date.now();
                }
            }

            placePiece() {
                if (!this.currentPiece) return;

                const shape = this.currentPiece.shape;
                for (let row = 0; row < shape.length; row++) {
                    for (let col = 0; col < shape[row].length; col++) {
                        if (shape[row][col]) {
                            const gridRow = this.currentPiece.row + row;
                            const gridCol = this.currentPiece.col + col;

                            if (gridRow >= 0 && gridRow < this.ROWS && gridCol >= 0 && gridCol < this.COLS) {
                                this.grid[gridRow][gridCol] = this.currentPiece.color;
                            }
                        }
                    }
                }

                this.checkLineClears();

                if (!this.generateNewPieceFromQueue()) {
                    this.gameOver();
                }

                this.updateUI();
            }

            generateNewPieceFromQueue() {
                this.currentPiece = null;
                this.generateNewPiece();
                return this.currentPiece !== null;
            }

            checkLineClears() {
                const linesToClear = [];

                for (let row = 0; row < this.ROWS; row++) {
                    if (this.grid[row].every(cell => cell !== 0)) {
                        linesToClear.push(row);
                    }
                }

                if (linesToClear.length > 0) {
                    this.clearLines(linesToClear);
                }
            }

            clearLines(lines) {
                lines.sort((a, b) => b - a);

                lines.forEach(row => {
                    this.grid.splice(row, 1);
                    this.grid.unshift(Array(this.COLS).fill(0));
                });

                const points = [0, 100, 300, 500, 800][lines.length];
                this.score += points * this.level;
                this.lines += lines.length;

                this.level = Math.floor(this.lines / 10) + 1;

                this.updateUI();
            }

            gameOver() {
                this.isGameOver = true;
                this.isPaused = true;
                this.updateUI();
            }

            draw() {
                if (!this.ctx) return;

                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                this.ctx.fillRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);

                this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                this.ctx.lineWidth = 1;

                for (let row = 0; row <= this.ROWS; row++) {
                    const y = row * this.CELL_SIZE;
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, y);
                    this.ctx.lineTo(this.ctx.canvas.width, y);
                    this.ctx.stroke();
                }
                for (let col = 0; col <= this.COLS; col++) {
                    const x = col * this.CELL_SIZE;
                    this.ctx.beginPath();
                    this.ctx.moveTo(x, 0);
                    this.ctx.lineTo(x, this.ctx.canvas.height);
                    this.ctx.stroke();
                }

                for (let row = 0; row < this.ROWS; row++) {
                    for (let col = 0; col < this.COLS; col++) {
                        if (this.grid[row][col]) {
                            this.drawCell(row, col, this.grid[row][col]);
                        }
                    }
                }

                if (this.currentPiece) {
                    this.drawPiece(this.currentPiece);
                }
            }

            drawCell(row, col, color) {
                const x = col * this.CELL_SIZE;
                const y = row * this.CELL_SIZE;

                this.ctx.fillStyle = color;
                this.ctx.fillRect(1, 1, this.CELL_SIZE - 2, this.CELL_SIZE - 2);

                this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                this.ctx.lineWidth = 1;
                this.ctx.strokeRect(1, 1, this.CELL_SIZE - 2, this.CELL_SIZE - 2);
            }

            drawPiece(piece) {
                const shape = piece.shape;
                for (let row = 0; row < shape.length; row++) {
                    for (let col = 0; col < shape[row].length; col++) {
                        if (shape[row][col]) {
                            const cellRow = piece.row + row;
                            const cellCol = piece.col + col;
                            this.drawCell(cellRow, cellCol, piece.color);
                        }
                    }
                }
            }

            updateUI() {
                const statusDot = document.getElementById('statusDot');
                const statusText = document.getElementById('statusText');
                const scoreDisplay = document.getElementById('scoreDisplay');

                if (this.isGameOver) {
                    statusDot.className = 'status-dot game-over';
                    statusText.textContent = 'Game Over';
                } else if (this.isPaused) {
                    statusDot.className = 'status-dot paused';
                    statusText.textContent = 'Paused';
                } else {
                    statusDot.className = 'status-dot playing';
                    statusText.textContent = 'Playing';
                }

                if (scoreDisplay) {
                    scoreDisplay.textContent = this.score;
                }
            }

            updateSystemStatus() {
                this.errorHandler.updateSystemStatus('logger', 'Active');
                this.errorHandler.updateSystemStatus('canvas', 'Active');
                this.errorHandler.updateSystemStatus('storage', 'Active');
            }
        }

        // Global game instance
        window.tetrisGame = null;
        let tetrisGame;

        // Global functions for buttons
        function startGame() {
            if (window.tetrisGame) window.tetrisGame.startGame();
        }

        function togglePause() {
            if (window.tetrisGame) window.tetrisGame.togglePause();
        }

        function movePieceLeft() {
            if (window.tetrisGame) window.tetrisGame.movePieceLeft();
        }

        function movePieceRight() {
            if (window.tetrisGame) window.tetrisGame.movePieceRight();
        }

        function movePieceDown() {
            if (window.tetrisGame) window.tetrisGame.movePieceDown();
        }

        function rotatePiece() {
            if (window.tetrisGame) window.tetrisGame.rotatePiece();
        }

        function hardDropPiece() {
            if (window.tetrisGame) window.tetrisGame.hardDropPiece();
        }

        // Initialize application
        document.addEventListener('DOMContentLoaded', () => {
            initializeTheme();

            const gameCanvas = document.getElementById('gameCanvas');
            if (!gameCanvas) {
                console.error('Game canvas not found');
                return;
            }

            tetrisGame = new TetrisGame(gameCanvas);
            window.tetrisGame = tetrisGame;

            tetrisGame.gameLoop();

            console.log('üéÆ Tetris Game loaded successfully!');
        });

        // Listen for system theme changes
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', (e) => {
            const body = document.body;
            const currentTheme = body.getAttribute('data-theme');

            if (currentTheme === 'auto' || !currentTheme) {
                applyTheme('auto');
            }
        });
    </script>
</body>
</html>